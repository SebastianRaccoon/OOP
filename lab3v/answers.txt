Ответы на 3 лабу ООП

1)ООП - это методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

Инкапсуляция – механизм сохраняющий данные и код, от внешнего воздействия и ошибочного использования.

Наследование – процесс благодаря которому, один объект может наследовать свойства другого, позволяющий описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Полиморфизм – способность вызывать метод наследника через объект предка.

Абстракция — означает выделение значимой информации и исключение из рассмотрения незначимой. Это разделение программы на объекты. Абстракция позволяет отобрать главные характеристики и опустить второстепенные.

2) System. Object

3) Конструктор класса – это специальный метод (функция) класса. Конструктор вызывается при создании объекта класса. Как правило, конструктор используется для: выделения памяти под объект класса; начальной инициализации внутренних данных класса.
Конструктор предназначен для формирования экземпляра объекта класса. Имя конструктора класса совпадает с именем класса.

Статический конструктор, конструктор по умолчанию, конструктор с параметрами.


4) Статический конструктор вызывается перед созданием экземпляра класса и не имеет параметров

5) Вызывается непосредственно перед окончательным уничтожением объекта системой «сборки мусора» чтобы гарантировать чёткое окончание срока действия объекта.

6) Поле это любая переменная с данными, а свойство это определение её метода записи и чтения

7) В чем отличие между объектом и классом?

Объект - экземпляр класса - объект, типом которого является какой-то класс. Объект после инициализации - сущность в памяти, обладающая поведением, способная изменять своё состояние.

8) классическое, автоматическое, get only, set only

9) Модификатор static используется для объявления статического члена, принадлежащего собственно типу, а не конкретному объекту. Статические классы объявляются с модификатором static и могут содержать только статические поля, свойства и методы.

10) readonly переменные можно изменять в конструкторах класса, const нет

11) Модификаотры доступауказывают кто и откуда может получить доступ к данным. Public, private, protected, internal. public - доступ не ограничен – все члены во
всех сборках. private - по умолчанию для членов
класса (используется для вложенных классов).
Доступен только методам в определяющем
типе и вложенных в него типах. protected - (используется для вложенных
классов) Доступен только методам в
определяющем типе (и вложенных в него
типах) или в одном из его производных типов
независимо от сборки. internal - доступ только из данной сборки

12) private

13) Ref – В C# указание модификатора ref приводит к созданию вызова по ссылке вместо вызова по значению. Данный модификатор указывается при объявлении метода и при его вызове.

Out – Модификатор используется для возврата более одного значения из метода. Отличие out от ref состоит в том что передаваемую переменную не обязательно инициализировать. Также метод объявленный с модификатором out обязан присвоить значение соответствующей переменной, до своего завершения и передачи управления вызывающей функции.

14) 

15)Ключевое слово partial указывает, что другие части класса, структуры или интерфейса могут быть определены в пространстве имен. Все части должны использовать ключевое слово partial. Для формирования окончательного типа все части должны быть доступны во время компиляции. Все части должны иметь одинаковые модификаторы доступа, например public, private и т. д.
Да. 
Объявления разделяемого метода должны начинаться с контекстно-зависимого ключевого слова partial, а метод должен возвращать значение типа void.
Разделяемые методы могут иметь параметры in или ref, но не out.
Разделяемые методы неявно имеют модификатор private и поэтому не могут иметь модификатор virtual.
Разделяемые методы не могут иметь модификатор extern, поскольку наличие тела определяет, выполняется ли их определение или реализация.
Разделяемые методы могут иметь модификаторы static и unsafe.
Разделяемые методы могут быть универсальными. Ограничения налагаются на ту часть объявления разделяемого метода, где находится определение, и могут дополнительно повторяться в разделе реализации. Имена параметров и типов параметров необязательно должны совпадать в объявлении реализации и в объявлении определения.
Можно использовать делегат в качестве определенного и реализованного разделяемого метода, но его нельзя использовать в качестве разделяемого метода, который только определен.

16.

17.

18. Свойства с параметрами. Позволяют индексировать объекты также, как и массивы или коллекции. (позволяют перегружать оператор [] ). Индексаторы могут быть одно- или многомерными.

атрибуты спецификаторы тип this [список_ параметров]

{

get //код доступа

}

{

set //код доступа

}

Ограничения на индексаторы:

1) Значение, выдаваемое индексатором, нельзя передавать методу в качестве параметра ref или out.

2) Индексатор не может быть объявлен как static.

19. Анонимные типы позволяют создать объект с некоторым набором свойств без определения класс.

var имя = new {параметр}

20. (shallow copy) Копия объекта, содержащая ссылки на другие объекты, но не копии этих объектов.

(deep copy) Если классы должны поддерживать полную копию, которая включает копии объектов, на которые она ссылается, то нужно реализовать интерфейс ICloneable и вручную производить клонирование или копирование.
